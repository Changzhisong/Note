## rand函数的实现原理

关于“随机数”产生有许多算法，但无论如何，都不可能产生真正随机数，因为电脑程序是个确定状态转换机，一种输入必定产生一种确定输出。因此rand函数产生的是伪随机数，也就是说它不是一个“真正的”随机数。  
但要实现“不可预知”还是可以做到的，只需有“不可预知”的输入或者初始化就可以了，像系统时间，网络实时带宽，Cpu使用率等等都可以作为“不可预知”的量来初始化随机函数。  

那么伪随机数是怎么实现的呢？原理大概如下：  

**如果约定：$a_1=f(seed),a_{n+1}=f(a_n)$，那么可以得到一个序列：$a_1,a_2,a_3,...,a_n$，因此要构造一个伪随机函数rand，
只需要让它每调用一次就返回序列的下一个元素就行。就相当于第1次调用rand返回$a_1$，第2次返回$a_2$，…，第n次返回$a_n$，
这样每次调rand都能得到一个不同的数，只要整个序列的规律不明显，整个函数看起来就是随机的。**  

现在计算机上的rand函数都是用这样的原理实现的，这里的`seed`被称为“随机数种子”。

但这里有一个问题，如果seed不变，那我们每次调用rand函数获取的序列都是相同的。这就会造成有的程序跑一遍退出后，再重新跑一遍，两次的输出结果是相同的。所以我们还需要一个接口去设置seed值，这个接口就是srand函数(c语言中)。如果你没有调用srand设置随机数种子，seed的默认值会是0，而seed为0时所决定的序列是固定的，而第一次调用rand()就是返回这个固定序列里的第1个元素，那它的值也是固定的，自然你的程序每次输出都一样了。所以正确的写法应该是程序初始化时用srand设置不同的随机数种子（只需要设置一次），例如`srand(time(NULL))`，但要注意，time(NULL)的值是隔1秒才改变一次的，必要情况下可以考虑使用精度更高的时间函数，如`gettimeofday`。  

在JAVA中，若调用`new Random()`系统默认将随机数生成器的种子设置为某个值，该值与此构造方法的所有其他调用所用的值完全不同，与当前的时间有关。若调用` new Random(seed) `则等效于：  

     Random rnd = new Random();  
     rnd.setSeed(seed); //设置随机数种子

----
#### 线性同余法(Linear Congruential Generator)

$$a_1=f(seed)，a_i = (a_{i-1} * A + C ) mod {M} $$

其中A,C,M都是常数（一般会取质数），比较敏感，或者说直接影响了伪随机数产生的质量。一般而言，LCG的M是2的指数次幂(一般2^32或者2^64,Java中是2^48)，因为这样取模操作截断最右的32或64位就可以了。多数编译器的库中使用了该理论实现其伪随机数发生器rand()。当C=0时，叫做乘同余法。  

随机数种子seed，它会决定随机值$a_1$，然后每次调用rand()函数都会用上一次产生的随机值来生成新的随机值。可以看出实际上用rand()函数生成的是一个递推的序列，一切值都来源于最初的seed。所以当初始的seed取一样的时候，得到的序列都相同。  

----
#### 梅森旋转算法（Mersenne Twister）
*** ...... ***